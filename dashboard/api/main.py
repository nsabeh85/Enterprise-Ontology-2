"""
===============================================================================
NEXUS DASHBOARD BACKEND - MAIN APPLICATION
===============================================================================

File: dashboard/api/main.py
Created: 2024-12-15
Purpose: FastAPI application entry point for the Nexus Dashboard API

WHY THIS FILE EXISTS:
---------------------
Previously, the dashboard loaded data from static JSON files that were manually
generated by running transform_to_dashboard.py. This created several problems:
  1. Data was always stale (had to manually run Python script)
  2. Full pipeline ran every time (expensive, slow)
  3. No real-time updates

This FastAPI backend solves these issues by:
  1. Providing REST API endpoints for the React dashboard
  2. Running incremental syncs (only fetch new data since last sync)
  3. Caching data in memory for fast response times
  4. Background scheduler for automatic periodic updates

ARCHITECTURE:
-------------
    ┌─────────────┐     ┌──────────────────────────────────────┐
    │  Cosmos DB  │────▶│  FastAPI Backend                     │
    └─────────────┘     │  ├── SyncService (incremental sync)  │
                        │  ├── Cache (in-memory data store)    │
                        │  └── API Endpoints                   │
                        └──────────────────────────────────────┘
                                          │
                                          ▼
                        ┌──────────────────────────────────────┐
                        │  React Dashboard (polls every 30s)   │
                        └──────────────────────────────────────┘

HOW TO RUN:
-----------
    cd dashboard/api
    uvicorn main:app --reload --port 8000

ENDPOINTS:
----------
    GET /api/rewriter     - Query rewriter metrics
    GET /api/adoption     - User adoption metrics
    GET /api/feedback     - Feedback analysis
    GET /api/status       - Sync status and health check
    POST /api/sync        - Trigger manual sync

===============================================================================
"""

import os
from contextlib import asynccontextmanager
from datetime import datetime

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware

# Import our custom services
from services.sync_service import SyncService
from services.metrics_service import MetricsService
from cache.state import CacheState

# ============================================================================
# LIFESPAN MANAGEMENT
# ============================================================================
# 
# WHY: FastAPI's lifespan context manager handles startup/shutdown events.
# We use this to:
#   1. Initialize the cache and services on startup
#   2. Run an initial data sync
#   3. Start the background scheduler for periodic syncs
#   4. Clean up resources on shutdown

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Manages application lifecycle:
    - STARTUP: Initialize services, run initial sync, start scheduler
    - SHUTDOWN: Stop scheduler, cleanup connections
    """
    print("=" * 60)
    print("NEXUS DASHBOARD BACKEND - STARTING")
    print("=" * 60)
    
    # Initialize the cache (stores our data in memory)
    app.state.cache = CacheState()
    
    # Initialize the sync service (handles Cosmos DB connections)
    app.state.sync_service = SyncService(app.state.cache)
    
    # Initialize the metrics service (calculates aggregations)
    app.state.metrics_service = MetricsService(app.state.cache)
    
    # Run initial sync to populate cache
    print("\n[STARTUP] Running initial data sync...")
    try:
        await app.state.sync_service.full_sync()
        print("[STARTUP] Initial sync complete!")
    except Exception as e:
        print(f"[STARTUP] Warning: Initial sync failed: {e}")
        print("[STARTUP] API will start but data may be unavailable")
    
    # Start background scheduler for periodic syncs
    app.state.sync_service.start_scheduler()
    
    print("\n[STARTUP] Backend ready!")
    print(f"[STARTUP] API available at http://localhost:8000")
    print("=" * 60)
    
    yield  # Application is running
    
    # Shutdown
    print("\n[SHUTDOWN] Stopping scheduler...")
    app.state.sync_service.stop_scheduler()
    print("[SHUTDOWN] Cleanup complete")


# ============================================================================
# FASTAPI APP INITIALIZATION
# ============================================================================
#
# WHY: We create the FastAPI app with:
#   - Descriptive metadata for the auto-generated docs
#   - Lifespan handler for startup/shutdown
#   - CORS middleware to allow React frontend to call the API

app = FastAPI(
    title="Nexus Dashboard API",
    description="Backend API for the Nexus Query Optimizer Dashboard. Provides real-time metrics with incremental updates.",
    version="1.0.0",
    lifespan=lifespan,
)

# ============================================================================
# CORS MIDDLEWARE
# ============================================================================
#
# WHY CORS IS NEEDED:
# The React dashboard runs on http://localhost:5173 (Vite dev server)
# The FastAPI backend runs on http://localhost:8000
# Browsers block cross-origin requests by default for security.
# This middleware tells the browser it's okay for the frontend to call our API.
#
# SECURITY NOTE:
# In production, you should restrict origins to your actual domain.
# For local development, we allow all origins with "*".

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:5173",  # Vite dev server
        "http://localhost:3000",  # Alternative React port
        "http://127.0.0.1:5173",
        "http://127.0.0.1:3000",
        "*",  # Allow all for development - CHANGE IN PRODUCTION
    ],
    allow_credentials=True,
    allow_methods=["*"],  # Allow all HTTP methods
    allow_headers=["*"],  # Allow all headers
)


# ============================================================================
# API ENDPOINTS
# ============================================================================

@app.get("/")
async def root():
    """
    Root endpoint - basic health check and API info.
    
    WHY: Useful for quick verification that the server is running.
    """
    return {
        "name": "Nexus Dashboard API",
        "version": "1.0.0",
        "status": "running",
        "docs": "/docs",
    }


@app.get("/api/status")
async def get_status():
    """
    Get sync status and system health.
    
    WHY: The dashboard can use this to:
      1. Show when data was last updated
      2. Display sync errors if any
      3. Show a "syncing" indicator during refresh
    
    RETURNS:
        {
            "last_sync": "2024-12-15T10:30:00Z",
            "is_syncing": false,
            "sync_interval_minutes": 5,
            "cache_stats": {
                "rewriter_records": 150,
                "adoption_records": 2000,
                "feedback_records": 500
            },
            "errors": []
        }
    """
    cache = app.state.cache
    sync_service = app.state.sync_service
    
    return {
        "last_sync": cache.last_sync_timestamp.isoformat() if cache.last_sync_timestamp else None,
        "is_syncing": sync_service.is_syncing,
        "sync_interval_minutes": sync_service.sync_interval_minutes,
        "cache_stats": {
            "rewriter_records": len(cache.rewriter_data),
            "adoption_records": len(cache.adoption_data),
            "feedback_records": len(cache.feedback_data),
        },
        "errors": cache.sync_errors[-5:],  # Last 5 errors
    }


@app.get("/api/rewriter")
async def get_rewriter_metrics():
    """
    Get query rewriter metrics.
    
    WHY: This endpoint replaces the static data.json import.
    
    The React dashboard calls this instead of:
        import data from '../data.json';
    
    Now it does:
        const data = await fetch('/api/rewriter').then(r => r.json());
    
    RETURNS:
        Same structure as the old data.json:
        {
            "summary": {...},
            "effectiveness": {...},
            "latencyStats": {...},
            "qualityScores": {...},
            "topEntities": [...],
            "rewrittenQueries": [...],
            "zeroResultQueries": [...],
            "metadata": {
                "generatedAt": "...",
                "lastSync": "..."
            }
        }
    """
    metrics_service = app.state.metrics_service
    cache = app.state.cache
    
    # Calculate metrics from cached data
    metrics = metrics_service.calculate_rewriter_metrics()
    
    # Add metadata
    metrics["metadata"] = {
        "generatedAt": datetime.now().isoformat(),
        "lastSync": cache.last_sync_timestamp.isoformat() if cache.last_sync_timestamp else None,
        "dataSource": "cosmos_staging",
        "recordCount": len(cache.rewriter_data),
    }
    
    return metrics


@app.get("/api/adoption")
async def get_adoption_metrics():
    """
    Get user adoption metrics.
    
    WHY: This endpoint replaces the static adoption.json import.
    
    RETURNS:
        Same structure as the old adoption.json:
        {
            "wau": 45,
            "mau": 120,
            "stickiness": 37.5,
            "totalQueries": 5000,
            "totalUsers": 200,
            "queriesPerUser": 25.0,
            "avgResponseTimeMs": 3500,
            "peakHour": 14,
            "queryTrend": [...],
            "topUsers": [...],
            "metadata": {...}
        }
    """
    metrics_service = app.state.metrics_service
    cache = app.state.cache
    
    # Calculate metrics from cached data
    metrics = metrics_service.calculate_adoption_metrics()
    
    # Add metadata
    metrics["metadata"] = {
        "generatedAt": datetime.now().isoformat(),
        "lastSync": cache.last_sync_timestamp.isoformat() if cache.last_sync_timestamp else None,
        "dataSource": "cosmos_production",
        "recordCount": len(cache.adoption_data),
    }
    
    return metrics


@app.get("/api/feedback")
async def get_feedback_metrics():
    """
    Get feedback analysis metrics.
    
    WHY: This endpoint replaces the static feedback.json import.
    
    RETURNS:
        Same structure as the old feedback.json:
        {
            "summary": {
                "total": 100,
                "thumbsUp": 70,
                "thumbsDown": 30,
                "positiveRate": 70.0
            },
            "trend": [...],
            "categoryBreakdown": [...],
            "feedbackItems": [...],
            "metadata": {...}
        }
    """
    metrics_service = app.state.metrics_service
    cache = app.state.cache
    
    # Calculate metrics from cached data
    metrics = metrics_service.calculate_feedback_metrics()
    
    # Add metadata
    metrics["metadata"] = {
        "generatedAt": datetime.now().isoformat(),
        "lastSync": cache.last_sync_timestamp.isoformat() if cache.last_sync_timestamp else None,
        "dataSource": "cosmos_production",
        "recordCount": len(cache.feedback_data),
    }
    
    return metrics


@app.post("/api/sync")
async def trigger_sync(full: bool = False):
    """
    Manually trigger a data sync.
    
    WHY: Allows manual refresh without waiting for the scheduled interval.
    Useful for:
      1. Testing
      2. Forcing an update after data changes
      3. Admin operations
    
    PARAMETERS:
        full: If True, runs a full sync (re-fetch all data)
              If False (default), runs incremental sync (only new data)
    
    RETURNS:
        {
            "success": true,
            "sync_type": "incremental",
            "records_added": {
                "rewriter": 5,
                "adoption": 20,
                "feedback": 3
            }
        }
    """
    sync_service = app.state.sync_service
    
    if sync_service.is_syncing:
        raise HTTPException(
            status_code=409,  # Conflict
            detail="A sync is already in progress. Please wait."
        )
    
    try:
        if full:
            result = await sync_service.full_sync()
            sync_type = "full"
        else:
            result = await sync_service.incremental_sync()
            sync_type = "incremental"
        
        return {
            "success": True,
            "sync_type": sync_type,
            "records_added": result,
        }
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Sync failed: {str(e)}"
        )


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================
#
# WHY: This allows running the app directly with `python main.py`
# However, for development with hot-reload, use:
#     uvicorn main:app --reload --port 8000

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",  # App as import string for reload to work
        host="0.0.0.0",
        port=8000,
        reload=True,  # Auto-reload on code changes
    )



